ORG 0
GUARD Base

\\ This is a temporary zero page buffer which is utilised like a stack frame
\\ Subroutines will alias values in this buffer according to their local needs,
\\ taking into account the allocation needs of child subroutine calls.
\\ TODO: write an assembler which can do this work for me :)

.zpTempStart		SKIP 32
.zpTempEnd

\\ Uninitialized zero page variables

.spriteFreePtr		SKIP 1
.spriteActiveNum	SKIP 1
.reqScrn			SKIP 2
.reqLine			SKIP 1
.scrnBase			SKIP 2

\\ Zero page variables initialized to zero at startup

.zpZeroStart
.irqLine			EQUB 0
.irqVsync			EQUB 0
.reqUpdate			EQUB 0
.zpZeroEnd

\\ A special temporary location which can be used by long subroutines.
\\ It provides a handy RTS in its operand so the routine can conditionally exit
\\ without out-of-range problems
SKIPTO &60
.temprts			SKIP 1

\\ Zero page variables which need explicit initialization

SKIPTO &80
.beginning
.irqScrn			EQUW (ScreenBaseAddr DIV 8)

; 5 more bytes free here

SKIPTO &87


\\ Masked sprite routine in zero page, for speed
.renderMasked0
	sprite = P%+1:LDA &FFFF,Y:STA maskIndex0
	maskIndex0 = P%+1:LDA MaskTab
	screen = P%+1:AND &FFFF,Y
	ORA maskIndex0:STA (screen),Y:INY

.renderMasked1
	LDA (sprite),Y:STA maskIndex1
	maskIndex1 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex1:STA (screen),Y:INY

.renderMasked2
	LDA (sprite),Y:STA maskIndex2
	maskIndex2 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex2:STA (screen),Y:INY

.renderMasked3
	LDA (sprite),Y:STA maskIndex3
	maskIndex3 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex3:STA (screen),Y:INY

.renderMasked4
	LDA (sprite),Y:STA maskIndex4
	maskIndex4 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex4:STA (screen),Y:INY

.renderMasked5
	LDA (sprite),Y:STA maskIndex5
	maskIndex5 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex5:STA (screen),Y:INY

.renderMasked6
	LDA (sprite),Y:STA maskIndex6
	maskIndex6 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex6:STA (screen),Y:INY

.renderMasked7
	LDA (sprite),Y:STA maskIndex7
	maskIndex7 = P%+1:LDA MaskTab
	AND (screen),Y:ORA maskIndex7:STA (screen),Y

	CLC
	JMP nextSpriteBlock


SKIPTO &FC
	BRK			; gets unavoidably corrupted by OS IRQ handler


\\ Render a character aligned sprite row.
\\ On entry:
\\  X = number of character blocks width
\\	(sprite) = sprite data
\\	(screen) = screen address
\\	spriteLine = screen/sprite offset
\\ On exit:
\\  C clear, X=0
.renderSpriteRow

	spriteRenderMask = zpTempStart + 0

	spriteLine = P%+1:LDY #0
	LSR spriteRenderMask
	BCC renderOverwrite7
	.renderSpriteBranchDest
	JMP renderMasked0


\\ Overwrite screen memory directly, no masking
.renderOverwrite0
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite1
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite2
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite3
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite4
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite5
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite6
	LDA (sprite),Y:STA (screen),Y:INY
.renderOverwrite7
	SAMEPAGE renderOverwrite0
	LDA (sprite),Y:STA (screen),Y


.nextSpriteBlock
	DEX
	BEQ spriteFinished

	; sprite data format has column data &100 bytes apart
	INC sprite+1

	; C already clear, either from overwrite path, or explicitly from masked path
	LDA screen:ADC #8:STA screen
	BCC renderSpriteRow
	CLC
	INC screen+1
	BPL renderSpriteRow
	LDA #HI(ScreenBaseAddr):STA screen+1
	BNE renderSpriteRow

.spriteFinished
	RTS


\\ Tables for configuring the height of the plotted sprite
\\ Height in X (1-8):
\\		LDA spriteMaskedRoutines,X:STA renderSpriteBranchDest+1
\\		LDA spriteOverwriteRoutines,X:STA renderSpriteBranchDest-1
\\ For heights<>8, restore to default aferwards with:
\\		LDA #LO(renderMasked0):STA renderSpriteBranchDest+1
\\		LDA #renderOverwrite0 - renderSpriteBranchDest:STA renderSpriteBranchDest-1
spriteMaskedRoutines = P%-1
	EQUB LO(renderMasked7)
	EQUB LO(renderMasked6)
	EQUB LO(renderMasked5)
	EQUB LO(renderMasked4)
	EQUB LO(renderMasked3)
	EQUB LO(renderMasked2)
	EQUB LO(renderMasked1)
	EQUB LO(renderMasked0)

spriteOverwriteRoutines = P%-1
	EQUB renderOverwrite7 - renderSpriteBranchDest
	EQUB renderOverwrite6 - renderSpriteBranchDest
	EQUB renderOverwrite5 - renderSpriteBranchDest
	EQUB renderOverwrite4 - renderSpriteBranchDest
	EQUB renderOverwrite3 - renderSpriteBranchDest
	EQUB renderOverwrite2 - renderSpriteBranchDest
	EQUB renderOverwrite1 - renderSpriteBranchDest
	EQUB renderOverwrite0 - renderSpriteBranchDest


\\ Erase a character aligned sprite row.
\\ On entry:
\\  X = number of character blocks width
\\	(screen) = screen address
\\	eraseLine = screen/sprite offset
.renderErase
	CLC
	LDA #0
	.renderEraseLoop
	eraseLine = P%+1:LDY #0
	.renderEraseDest
	JMP renderErase0

\\ Erase block, assuming A=0
.renderErase0
	STA (screen),Y:INY
.renderErase1
	STA (screen),Y:INY
.renderErase2
	STA (screen),Y:INY
.renderErase3
	STA (screen),Y:INY
.renderErase4
	STA (screen),Y:INY
.renderErase5
	STA (screen),Y:INY
.renderErase6
	STA (screen),Y:INY
.renderErase7
	SAMEPAGE renderErase0
	STA (screen),Y

	DEX
	BEQ spriteFinished

	; We maintain C clear throughout this routine
	LDA screen:ADC #8:STA screen
	BCC renderEraseLoop
	CLC
	INC screen+1
	BPL renderEraseLoop
	LDA #HI(ScreenBaseAddr):STA screen+1
	BNE renderEraseLoop


\\ Tables for configuring the height of the erased block
\\ Height in X (1-8):
\\		LDA eraseRoutines,X:STA renderEraseDest+1
\\ Afterwards set back to default (8):
\\		LDA #LO(renderErase0):STA renderEraseDest+1
eraseRoutines = P%-1
	EQUB LO(renderErase7)
	EQUB LO(renderErase6)
	EQUB LO(renderErase5)
	EQUB LO(renderErase4)
	EQUB LO(renderErase3)
	EQUB LO(renderErase2)
	EQUB LO(renderErase1)
	EQUB LO(renderErase0)



\\ Clear the screen to zero

.cls
{
	IF SMALL_SCREEN
		LDA #&58:STA clsLoop+2
		LDX #&28
	ELSE
		LDA #&40:STA clsLoop+2
		TAX
	ENDIF

	LDA #0:TAY
	.clsLoop
	STA &FF00,Y
	INY:BNE clsLoop
	INC clsLoop+2
	DEX:BNE clsLoop
	RTS
}


.enableScreen
	LDA #&C0
	PCSKIP2		; skip LDA #&F0 below
.disableScreen
	LDA #&F0
	STA irqScreenEnabled+1
	RTS


\\ Stack

.stack
	SKIP 16
.stackTop




PRINT "Wasted", ~&204-P%, "bytes"
SKIPTO &204
	EQUW irq
	
	
	

SKIPTO &258
	EQUB 2


\\ Irq related code

.irq
	BIT &FE4D
	BVS irqScrnTop
	.irqBranchDest

	LDA &FC
	RTI
	
.irqScrnTop
	LDA #8:STA &FE00
	.irqScreenEnabled LDA #&F0:STA &FE01
	LDA #6:STA &FE00:LDA #GameHeight+1:STA &FE01
	LDA #7:STA &FE00:LDA #255:STA &FE01
	LDA #4:STA &FE00:LDA #GameHeight-1:STA &FE01
	LDA #5:STA &FE00:LDA irqLine:STA &FE01
	LDA #12:STA &FE00:LDA #HI(ScreenStatusAddr DIV 8):STA &FE01
	LDA #13:STA &FE00:LDA #LO(ScreenStatusAddr DIV 8):STA &FE01
	LDA #(irqScrnBottom-irqBranchDest):STA irqBranchDest-1
	LDA #HI(4 * 8 * 64 - 2):STA &FE47
	LDA &FC
	RTI

.irqScrnVeryBottom
	LDA #8:STA &FE00:LDA #&F0:STA &FE01
	LDA #(irqScrnTop-irqBranchDest):STA irqBranchDest-1
	LDA #HI(GameHeight * 8 * 64 - 2):STA &FE47
	LDA &FC
	RTI

.irqScrnBottom
	SAMEPAGE irqBranchDest
	INC irqVsync
	LDA reqUpdate:BEQ noUpdate
	LDA irqVsync:.frameCount CMP #1:BCC noUpdate
	LDA #0:STA reqUpdate:STA irqVsync
	LDA reqScrn:STA irqScrn
	LDA reqScrn+1:STA irqScrn+1
	LDA reqLine:STA irqLine
	.noUpdate
	LDA #6:STA &FE00:LDA #StatusHeight:STA &FE01
	LDA #7:STA &FE00:LDA #ScreenVSyncPos-GameHeight:STA &FE01
	LDA #5:STA &FE00:SEC:LDA #8:SBC irqLine:STA &FE01
	LDA #4:STA &FE00:LDA #37-GameHeight:STA &FE01
	LDA #12:STA &FE00:LDA irqScrn+1:STA &FE01
	LDA #13:STA &FE00:LDA irqScrn:STA &FE01
	LDA #(irqScrnVeryBottom-irqBranchDest):STA irqBranchDest-1
	LDA #HI((39 - 4 - GameHeight) * 8 * 64 - 2):STA &FE47
	LDA #&03:STA &FE21
	LDA &FC
	RTI

