\\ Initialise the sprite system
\\ No entry parameters
.initSprites
{
    ; Initialise the free list
    ; It contains indices of free sprite slots, accessed as a stack
    ; spriteFreePtr is the empty stack pointer
    ; When it is negative, there is no longer room for any sprites
    LDX #MaxSprites-1:STX spriteFreePtr
    LDA #0:STA spriteActiveNum
    CLC
    .loop
    STA SpriteFreeList,X
    ADC #1
    DEX
    BPL loop

    RTS
}


\\ On entry:
\\      A = sprite y pos
\\      Y = sprite height
\\ On exit:
\\      X = sprite index
\\      The caller will then have to set:
\\          SpriteNewX0,X
\\          SpriteNewX1,X
\\          SpriteAddrLo,X
\\          SpriteAddrHi,X
.createSpriteAtY
{
    spriteIndex = zpTempStart + 0
    spriteRow = zpTempStart + 1
    spriteHeight = zpTempStart + 2

    STY spriteHeight

    ; Get the next free sprite index in X
    LDY spriteFreePtr
    IF DEBUG:BMI P%:ENDIF       ; hang if no more sprites
    LDX SpriteFreeList,Y
    STX spriteIndex
    DEC spriteFreePtr

    ; Set sprite Y0 and Row0 values
    STA SpriteNewY0,X:STA SpriteOldY0,X
    AND #&F8                    ; 
    STA SpriteRow0,X
    STA spriteRow

    ; Now we have to find the index of its correct sorted position
    ; and make room by copying all higher entries up one place
    LDY spriteActiveNum
    .insertLoop
    DEY:BMI foundInsertIndex
    LDX SpriteActiveList,Y
    CMP SpriteRow0,X
    BCS foundInsertIndex
    TXA:STA SpriteActiveList+1,Y
    LDA spriteRow
    BCC insertLoop
    .foundInsertIndex

    ; Write the sprite index to its new sorted position
    INY
    LDA spriteIndex
    STA SpriteActiveList,Y
    TAX

    ; Now write Y1 and Row1
    LDA SpriteNewY0,X
    CLC:ADC spriteHeight:STA SpriteNewY1,X:STA SpriteOldY1,X
    AND #&F8
    STA SpriteRow1,X

    INC spriteActiveNum
    RTS
}


.destroySprite
{

}


.moveSprite
{

}


.noSprites
    RTS

.renderSprites
{
    ; renderSpriteRow uses 1 temporary zp
    rowStart = zpTempStart + 1
    rowEnd = zpTempStart + 2
    activeListIndex = zpTempStart + 3
    spriteRenderNum = zpTempStart + 4
    rowAddr = zpTempStart + 5
    tempIndex = zpTempStart + 7

    ; If there are no active sprites, we have nothing to do
    LDA spriteActiveNum:BEQ noSprites

    ; Initialise render list
    LDA #0:STA spriteRenderNum
    STA activeListIndex

    .rowLoop

    ; If there's nothing in the render list, the next entry in the active list determines
    ; the next row we need to render, so skip straight to it.
    ; If there's something in the render list then either we have sprite rows remaining
    ; which need rendering, or we need to remove the entries from the list if we've 
    ; passed their lower bound.

    LDA spriteRenderNum:BNE removeOldEntries

    ; SKIP TO NEXT OCCUPIED ROW (RENDER LIST EMPTY)
    ;----------------------------------------------
    ; This is the case where there's nothing in the render list
    ; We take the next entry from the active list and skip straight to that row.
    ; The first time entering the loop, we will always come here
    
    LDY spriteActiveNum
    LDX SpriteActiveList,Y      ; get next sprite index from active list
    LDA SpriteRow0,X            ; get top bounds
    STA rowStart                ; use that as the row start

    IF SMALL_SCREEN
        LSR A:LSR A             \ C always clear
        ADC scrnBase+1:STA rowAddr+1
        LDA scrnBase:STA rowAddr
    ELSE
        LSR A:LSR A:LSR A       \ C always clear
        TAY
        LDA scrnBase:ADC RowTabLo,Y:STA rowAddr
        LDA scrnBase+1:ADC RowTabHi,Y:STA rowAddr+1
    ENDIF

    LDA rowStart                \ C always clear
    ADC #8:STA rowEnd

    TXA:STA SpriteRenderList
    INC spriteRenderNum
    JMP addNewEntries

    .removeOldEntries

    ; REMOVE FROM RENDER LIST
    ;------------------------
    ; If there are entries in the render list, see if any of them need to be removed
    ; i.e. when the sprite dirty bounds don't overlap this row

    ; Move to next row
    LDA rowEnd:STA rowStart
    CLC:ADC #8:STA rowEnd

    IF SMALL_SCREEN
        LDA rowAddr+1:ADC #2:BPL P%+4:SBC #&27:STA rowAddr+1
    ELSE
        LDA rowAddr:ADC #LO(ScreenWidth * 8):STA rowAddr
        LDA rowAddr+1:ADC #HI(ScreenWidth *8):BPL P%+4:SBC #&40:STA rowAddr+1
    ENDIF

    ; Iterate render list (sprite index order)
    ; If we find a sprite whose Row1 (bottom bounds) is less than or equal to the current row start,
    ; remove it from the render list. This will still leave it in sorted index order.

    ; First of all, try to iterate through as many items as possible without needing to
    ; copy anything
    LDY #0
    LDA rowStart
    .removeLoop
    LDX SpriteRenderList,Y
    CMP SpriteRow1,X:BCS needToRemove   ; need to copy from now on
    INY:CPY spriteRenderNum
    BNE removeLoop
    JMP addNewEntries

    ; If we got here, we have to remove at least one item, and that means copying higher
    ; items down until the end. Hence this is a different loop to above.
    .needToRemove
    STY tempIndex               ; Y is the index to element to remove
    .removeLoop2
    INY:CPY spriteRenderNum
    BEQ removedAll
    LDX SpriteRenderList,Y
    CMP SpriteRow1,X
    BCS removeLoop2

    TXA:LDX tempIndex
    STA SpriteRenderList,X
    LDA rowStart
    INC tempIndex
    BNE removeLoop2

    .removedAll
    LDA tempIndex:STA spriteRenderNum

    .addNewEntries

    ; ADD TO RENDER LIST IN SORTED POSITION
    ;--------------------------------------

    RTS
}
