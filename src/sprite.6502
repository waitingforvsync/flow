\\ Initialise the sprite system
\\ No entry parameters
.initSprites
{
    ; Initialise the free list
    ; It contains indices of free sprite slots, accessed as a stack
    ; spriteFreePtr is the empty stack pointer
    ; When it is negative, there is no longer room for any sprites
    LDX #MaxSprites-1:STX spriteFreePtr
    LDA #0:STA spriteActiveNum
    CLC
    .loop
    STA SpriteFreeList,X
    ADC #1
    DEX
    BPL loop

    ; Default sprite routines - plot an entire 8 line block
	LDA #LO(renderMasked0):STA renderSpriteBranchDest+1
	LDA #renderOverwrite0 - renderSpriteBranchDest:STA renderSpriteBranchDest-1
    RTS
}


\\ On entry:
\\      A = sprite y pos
\\      Y = sprite height
\\ On exit:
\\      X = sprite index
\\      The caller will then have to set:
\\          SpriteNewX0,X
\\          SpriteNewX1,X
\\          SpriteAddrLo,X
\\          SpriteAddrHi,X
.createSpriteAtY
{
    spriteIndex = zpTempStart + 0
    spriteRow = zpTempStart + 1
    spriteHeight = zpTempStart + 2

    STY spriteHeight

    ; Get the next free sprite index in X
    LDY spriteFreePtr
    IF DEBUG:BMI P%:ENDIF       ; hang if no more sprites
    LDX SpriteFreeList,Y
    STX spriteIndex
    DEC spriteFreePtr

    ; Set sprite Y0 and Row0 values
    STA SpriteNewY0,X:STA SpriteOldY0,X
    AND #&F8                    ; 
    STA SpriteRow0,X
    STA spriteRow

    ; Now we have to find the index of its correct sorted position
    ; and make room by copying all higher entries up one place
    LDY spriteActiveNum
    .insertLoop
    DEY:BMI foundInsertIndex
    LDX SpriteActiveList,Y
    CMP SpriteRow0,X
    BCS foundInsertIndex
    TXA:STA SpriteActiveList+1,Y
    LDA spriteRow
    BCC insertLoop
    .foundInsertIndex

    ; Write the sprite index to its new sorted position
    INY
    LDA spriteIndex
    STA SpriteActiveList,Y
    TAX

    ; Now write Y1 and Row1
    LDA SpriteNewY0,X
    CLC:ADC spriteHeight:STA SpriteNewY1,X:STA SpriteOldY1,X
    ADC #7:AND #&F8
    STA SpriteRow1,X

    INC spriteActiveNum
    RTS
}


.destroySprite
{

}


.moveSprite
{

}


.renderSpriteFinished
    RTS

.renderSprites
{
    ; renderSpriteRow uses 1 temporary zp
    rowStart = zpTempStart + 1
    rowEnd = zpTempStart + 2
    activeListIndex = zpTempStart + 3
    spriteRenderNum = zpTempStart + 4
    rowAddr = zpTempStart + 5
    tempIndex = zpTempStart + 7
    occupancyMask = zpTempStart + 8
    ; zpTempStart + 18

    ; ------------------- rowStart
    ;    +------+   y0
    ;    |      |
    ;    |      |
    ; ---+------+-------- rowEnd
    ;    |      |
    ;    +------+   y1
    ;
    ; -------------------

    ; To add an entry to the render list, y0 < rowEnd
    ; To remove an entry from the render list, rowStart >= y1

    ; Initialise render list
    LDA #0:STA spriteRenderNum
    STA activeListIndex

    .rowLoop

    ; If there's nothing in the render list, the next entry in the active list determines
    ; the next row we need to render, so skip straight to it.
    ; If there's something in the render list then either we have sprite rows remaining
    ; which need rendering, or we need to remove the entries from the list if we've 
    ; passed their lower bound.
    ; After that we'll walk the active list to add any other entries which need to be added
    ; to the render list.

    LDA spriteRenderNum:BNE processNextRow

    ; SKIP TO NEXT OCCUPIED ROW (RENDER LIST EMPTY)
    ;----------------------------------------------
    ; This is the case where there's nothing in the render list
    ; We take the next entry from the active list and skip straight to that row.
    ; The first time entering the loop, we will always come here
    
    ; If there's nothing left in the active list, we have finished
    LDY activeListIndex
    CPY spriteActiveNum:BEQ renderSpriteFinished

    LDX SpriteActiveList,Y      ; get next sprite index from active list
    INC activeListIndex         ; consume active list entry
    LDA SpriteRow0,X            ; get sprite top bounds
    STA rowStart                ; use that as the row start

    ; Calculate this row's screen address (taking into account the hardware scroll base)
    IF SMALL_SCREEN
        LSR A:LSR A             \ C always clear
        ADC scrnBase+1:BPL P%+4:SBC #HI(ScreenSize)-1:STA rowAddr+1
        LDA scrnBase:STA rowAddr
    ELSE
        LSR A:LSR A:LSR A       \ C always clear
        TAY
        LDA scrnBase:ADC RowTabLo,Y:STA rowAddr
        LDA scrnBase+1:ADC RowTabHi,Y:BPL P%+4:SBC #HI(ScreenSize)-1:STA rowAddr+1
    ENDIF

    CLC:LDA rowStart
    ADC #8:STA rowEnd

    ; Calculate X*8
    LDA SpriteNewX0,X:ASL A:ASL A:ROL A:ROL A:TAY:AND #&F0:ROR A
    STA SpriteColumnLo,X
    TYA:AND #3:STA SpriteColumnHi,X

    TXA:STA SpriteRenderList    ; list is empty, so write element 0 directly
    INC spriteRenderNum         ; spriteRenderNum=1
    JMP addNewEntries


    ; PROCESS NEXT ROW
    ;-----------------

    .processNextRow

    ; Set start/end for next row
    LDA rowEnd:STA rowStart
    CLC:ADC #8:STA rowEnd

    IF SMALL_SCREEN
        LDA rowAddr+1:ADC #2:BPL P%+4:SBC #HI(ScreenSize)-1:STA rowAddr+1
    ELSE
        LDA rowAddr:ADC #LO(ScreenWidth * 8):STA rowAddr
        LDA rowAddr+1:ADC #HI(ScreenWidth *8):BPL P%+4:SBC #HI(ScreenSize)-1:STA rowAddr+1
    ENDIF

    ; REMOVE FROM RENDER LIST
    ;------------------------
    ; If there are entries in the render list, see if any of them need to be removed
    ; i.e. when the sprite dirty bounds don't overlap this row

    ; Iterate render list (sprite index order)
    ; If we find a sprite whose Row1 (bottom bounds) is less than or equal to the current row start,
    ; remove it from the render list. This will still leave it in sorted index order.

    ; First of all, try to iterate through as many items as possible without needing to
    ; copy anything
    LDY #0
    LDA rowStart
    .removeLoop
    LDX SpriteRenderList,Y
    CMP SpriteRow1,X:BCS needToRemove   ; need to copy from now on
    INY:CPY spriteRenderNum
    BNE removeLoop
    JMP addNewEntries

    ; If we got here, we have to remove at least one item, and that means copying higher
    ; items down until the end. Hence this is a different loop to above.
    .needToRemove
    STY tempIndex               ; Y is the index to element to remove
    
    ; Skip past any contiguous entries which need to be removed.
    ; We have already skipped the first one
    ; At the end of this loop, Y points to the next valid entry in the render list
    .removeLoop2
    INY:CPY spriteRenderNum
    BEQ removedAll
    LDX SpriteRenderList,Y
    CMP SpriteRow1,X
    BCS removeLoop2

    ; X is the valid entry in the render list. Copy it down to the new position.
    TXA:LDX tempIndex
    STA SpriteRenderList,X
    LDA rowStart        ; corrupted A above, so get it back
    INC tempIndex       ; tempIndex is the new end of the list
    BNE removeLoop2

    .removedAll
    LDA tempIndex:STA spriteRenderNum


    ; ADD TO RENDER LIST IN SORTED POSITION
    ;--------------------------------------

    .addNewEntries

    ; If we have consumed the entire active list, there is nothing more to add.
    ; However we don't exit yet, because the render list may still have residual items.
    LDY activeListIndex
    CPY spriteActiveNum:BEQ processRenderList

    ; The active list is sorted by Y.
    ; So we iterate through it, adding zero or more items, until we encounter one whose
    ; top bounds is greater or equal to the current row end.
    .addLoop
    LDX SpriteActiveList,Y      ; get next sprite index from active list
    LDA SpriteRow0,X  
    CMP rowEnd                  ; are the top bounds less than the current row end?
    BCS processRenderList       ; no - nothing more to add

    ; Calculate X*8
    LDA SpriteNewX0,X:ASL A:ASL A:ROL A:ROL A:STA tempIndex:AND #&F0:ROR A
    STA SpriteColumnLo,X
    LDA tempIndex:AND #3:STA SpriteColumnHi,X

    ; The index we want to add to the render list is in X.
    ; Add it in index-sorted position by starting at the end of the render list
    ; and bubbling items up one place until we find the final resting place.
    STX tempIndex
    LDX spriteRenderNum
    .insertLoop
    DEX:BMI gotInsertPosition    ; we reached the start of the list, so it must go here
    LDA SpriteRenderList,X
    CMP tempIndex
    BCC gotInsertPosition
    STA SpriteRenderList+1,X
    BCS insertLoop

    ; Add the sprite index in the right position
    .gotInsertPosition
    INX
    LDA tempIndex
    STA SpriteRenderList,X
    INC spriteRenderNum

    ; Keep on iterating the active list until we hit the end
    INY
    STY activeListIndex
    CPY spriteActiveNum
    BNE addLoop

    .processRenderList

    ; PROCESS RENDER LIST
    ;--------------------

    LDY #0
    .renderRowLoop
    CPY spriteRenderNum:BEQ finishedRenderRow
    STY tempIndex
    LDX SpriteRenderList,Y

    ; Fetch and update cached screen address
    ; C clear from CPY spriteRenderNum
    LDA rowEnd:SBC SpriteNewY0,X:CMP #8:BCS alignedTop:TAY:EOR #7:BEQ alignedTop
    JMP (&FFFC) ; TODO start unaligned sprite rows
    .alignedTop
    CLC
    LDA rowAddr:ADC SpriteColumnLo,X:STA screen
    LDA rowAddr+1:ADC SpriteColumnHi,X:BPL P%+4:SBC #HI(ScreenSize)-1:STA screen+1

    SEC:LDA rowStart:SBC SpriteNewY0,X:CLC
    ADC SpriteAddrLo,X:STA sprite
    LDA SpriteAddrHi,X:STA sprite+1
    LDA #0:STA spriteLine:STA spriteRenderMask

    ; handle partial end sprite blocks
    SEC:LDA SpriteNewY1,X:SBC rowStart:CMP #8:BCS fullSpriteBlock
    TAY
	LDA spriteMaskedRoutines,Y:STA renderSpriteBranchDest+1
	LDA spriteOverwriteRoutines,Y:STA renderSpriteBranchDest-1
    .fullSpriteBlock

    LDA SpriteNewX1,X:SEC:SBC SpriteNewX0,X:TAX
    LDA #1:STA &FE21
    JSR renderSpriteRow
    LDA #3:STA &FE21

	LDA #LO(renderMasked0):STA renderSpriteBranchDest+1
	LDA #renderOverwrite0 - renderSpriteBranchDest:STA renderSpriteBranchDest-1

    LDY tempIndex
    INY
    BNE renderRowLoop

    .finishedRenderRow
    JMP rowLoop
}
