\\ Initialise the sprite system
\\ No entry parameters
.initSprites
{
    ; Initialise the free list
    ; It contains indices of free sprite slots, accessed as a stack
    ; spriteFreePtr is the empty stack pointer
    ; When it is negative, there is no longer room for any sprites
    LDX #MaxSprites-1:STX spriteFreePtr
    LDA #0:STA spriteActiveNum
    CLC
    .loop
    STA SpriteFreeList,X
    ADC #1
    DEX
    BPL loop

    ; Default sprite routines - plot an entire 8 line block
	LDA #LO(renderMasked0):STA renderSpriteBranchDest+1
	LDA #renderOverwrite0 - renderSpriteBranchDest:STA renderSpriteBranchDest-1
    LDA #0:STA spriteLine:STA spriteRenderMask

    RTS
}


\\ On entry:
\\      A = sprite y pos
\\      Y = sprite height
\\ On exit:
\\      X = sprite index
\\      The caller will then have to set:
\\          SpriteNewX0,X
\\          SpriteNewX1,X
\\          SpriteAddrLo,X
\\          SpriteAddrHi,X
.createSpriteAtY
{
    spriteIndex = zpTempStart + 0
    spriteRow = zpTempStart + 1
    spriteHeight = zpTempStart + 2

    STY spriteHeight

    ; Get the next free sprite index in X
    LDY spriteFreePtr
    IF DEBUG:BMI P%:ENDIF       ; hang if no more sprites
    LDX SpriteFreeList,Y
    STX spriteIndex
    DEC spriteFreePtr

    ; Set sprite Y0 and Row0 values
    STA SpriteNewY0,X:STA SpriteOldY0,X
    AND #&F8                    ; 
    STA SpriteRow0,X
    STA spriteRow

    ; Now we have to find the index of its correct sorted position
    ; and make room by copying all higher entries up one place
    LDY spriteActiveNum
    .insertLoop
    DEY:BMI foundInsertIndex
    LDX SpriteActiveList,Y
    CMP SpriteRow0,X
    BCS foundInsertIndex
    TXA:STA SpriteActiveList+1,Y
    LDA spriteRow
    BCC insertLoop
    .foundInsertIndex

    ; Write the sprite index to its new sorted position
    INY
    LDA spriteIndex
    STA SpriteActiveList,Y
    TAX

    ; Now write Y1 and Row1
    LDA SpriteNewY0,X
    CLC:ADC spriteHeight:STA SpriteNewY1,X:STA SpriteOldY1,X
    ADC #7:AND #&F8
    STA SpriteRow1,X

    INC spriteActiveNum
    RTS
}


.destroySprite
{

}


.moveSprite
{

}


.renderSpriteFinished
    RTS

.renderSprites
{
    ; renderSpriteRow uses 1 temporary zp
    rowStart = zpTempStart + 1
    rowEnd = zpTempStart + 2
    activeListIndex = zpTempStart + 3
    spriteRenderNum = zpTempStart + 4
    rowAddr = zpTempStart + 5
    tempIndex = zpTempStart + 7
    temp1 = zpTempStart + 8
    temp2 = zpTempStart + 9
    occupancyMask = zpTempStart + 10

    ; ------------------- rowStart
    ;    +------+   y0
    ;    |      |
    ;    |      |
    ; ---+------+-------- rowEnd
    ;    |      |
    ;    +------+   y1
    ;
    ; -------------------

    ; To add an entry to the render list, y0 < rowEnd
    ; To remove an entry from the render list, rowStart >= y1

    ; Initialise render list
    LDA #0:STA spriteRenderNum
    STA activeListIndex

    .rowLoop

    ; If there's nothing in the render list, the next entry in the active list determines
    ; the next row we need to render, so skip straight to it.
    ; If there's something in the render list then either we have sprite rows remaining
    ; which need rendering, or we need to remove the entries from the list if we've 
    ; passed their lower bound.
    ; After that we'll walk the active list to add any other entries which need to be added
    ; to the render list.

    LDA spriteRenderNum:BNE processNextRow

    ; SKIP TO NEXT OCCUPIED ROW (RENDER LIST EMPTY)
    ;----------------------------------------------
    ; This is the case where there's nothing in the render list
    ; We take the next entry from the active list and skip straight to that row.
    ; The first time entering the loop, we will always come here
    
    ; If there's nothing left in the active list, we have finished
    LDY activeListIndex
    CPY spriteActiveNum:BEQ renderSpriteFinished

    LDX SpriteActiveList,Y      ; get next sprite index from active list
    INC activeListIndex         ; consume active list entry
    LDA SpriteRow0,X            ; get sprite top bounds
    STA rowStart                ; use that as the row start

    ; Calculate this row's screen address (taking into account the hardware scroll base)
    IF SMALL_SCREEN
        LSR A:LSR A             \ C always clear
        ADC scrnBase+1:BPL P%+5:SBC #HI(ScreenSize)-1:CLC:STA rowAddr+1
        LDA scrnBase:STA rowAddr
    ELSE
        LSR A:LSR A:LSR A       \ C always clear
        TAY
        LDA scrnBase:ADC RowTabLo,Y:STA rowAddr
        LDA scrnBase+1:ADC RowTabHi,Y:BPL P%+5:SBC #HI(ScreenSize)-1:CLC:STA rowAddr+1
    ENDIF

    LDA rowStart
    ADC #8:STA rowEnd

    ; Calculate X*8 [we now use a table for this]
;    LDA SpriteNewX0,X:ASL A:ASL A:ROL A:ROL A:TAY:AND #&F0:ROR A
;    STA SpriteColumnLo,X
;    TYA:AND #3:STA SpriteColumnHi,X

    TXA:STA SpriteRenderList    ; list is empty, so write element 0 directly
    INC spriteRenderNum         ; spriteRenderNum=1
    JMP addNewEntries


    ; PROCESS NEXT ROW
    ;-----------------

    .processNextRow

    ; Set start/end for next row
    LDA rowEnd:STA rowStart
    CLC:ADC #8:STA rowEnd

    IF SMALL_SCREEN
        LDA rowAddr+1:ADC #2:BPL P%+4:SBC #HI(ScreenSize)-1:STA rowAddr+1
    ELSE
        LDA rowAddr:ADC #LO(ScreenWidth * 8):STA rowAddr
        LDA rowAddr+1:ADC #HI(ScreenWidth *8):BPL P%+4:SBC #HI(ScreenSize)-1:STA rowAddr+1
    ENDIF

    ; REMOVE FROM RENDER LIST
    ;------------------------
    ; If there are entries in the render list, see if any of them need to be removed
    ; i.e. when the sprite dirty bounds don't overlap this row

    ; Iterate render list (sprite index order)
    ; If we find a sprite whose Row1 (bottom bounds) is less than or equal to the current row start,
    ; remove it from the render list. This will still leave it in sorted index order.

    ; First of all, try to iterate through as many items as possible without needing to
    ; copy anything
    LDY #0
    LDA rowStart
    .removeLoop
    LDX SpriteRenderList,Y
    CMP SpriteRow1,X:BCS needToRemove   ; need to copy from now on
    INY:CPY spriteRenderNum
    BNE removeLoop
    JMP addNewEntries

    ; If we got here, we have to remove at least one item, and that means copying higher
    ; items down until the end. Hence this is a different loop to above.
    .needToRemove
    STY tempIndex               ; Y is the index to element to remove
    
    ; Skip past any contiguous entries which need to be removed.
    ; We have already skipped the first one
    ; At the end of this loop, Y points to the next valid entry in the render list
    .removeLoop2
    INY:CPY spriteRenderNum
    BEQ removedAll
    LDX SpriteRenderList,Y
    CMP SpriteRow1,X
    BCS removeLoop2

    ; X is the valid entry in the render list. Copy it down to the new position.
    TXA:LDX tempIndex
    STA SpriteRenderList,X
    LDA rowStart        ; corrupted A above, so get it back
    INC tempIndex       ; tempIndex is the new end of the list
    BNE removeLoop2

    .removedAll
    LDA tempIndex:STA spriteRenderNum


    ; ADD TO RENDER LIST IN SORTED POSITION
    ;--------------------------------------

    .addNewEntries

    ; If we have consumed the entire active list, there is nothing more to add.
    ; However we don't exit yet, because the render list may still have residual items.
    LDY activeListIndex
    CPY spriteActiveNum:BEQ processRenderList

    ; The active list is sorted by Y.
    ; So we iterate through it, adding zero or more items, until we encounter one whose
    ; top bounds is greater or equal to the current row end.
    .addLoop
    LDX SpriteActiveList,Y      ; get next sprite index from active list
    LDA SpriteRow0,X  
    CMP rowEnd                  ; are the top bounds less than the current row end?
    BCS processRenderList       ; no - nothing more to add

    ; Calculate X*8 [we now use a table for this]
;    LDA SpriteNewX0,X:ASL A:ASL A:ROL A:ROL A:STA tempIndex:AND #&F0:ROR A
;    STA SpriteColumnLo,X
;    LDA tempIndex:AND #3:STA SpriteColumnHi,X

    ; The index we want to add to the render list is in X.
    ; Add it in index-sorted position by starting at the end of the render list
    ; and bubbling items up one place until we find the final resting place.
    STX tempIndex
    LDX spriteRenderNum
    .insertLoop
    DEX:BMI gotInsertPosition    ; we reached the start of the list, so it must go here
    LDA SpriteRenderList,X
    CMP tempIndex
    BCC gotInsertPosition
    STA SpriteRenderList+1,X
    BCS insertLoop

    ; Add the sprite index in the right position
    .gotInsertPosition
    INX
    LDA tempIndex
    STA SpriteRenderList,X
    INC spriteRenderNum

    ; Keep on iterating the active list until we hit the end
    INY
    STY activeListIndex
    CPY spriteActiveNum
    BNE addLoop

    .processRenderList

    ; PROCESS RENDER LIST
    ;--------------------

    ; If the render list has changed (entries added or removed), we have to clear the occupancy mask
    ; and rebuild all the render masks.
    ; @TODO

    ; Here we have to erase all the dirty edges
    ; @TODO

    ; Render all the sprites
    LDA spriteRenderNum:BEQ finishedRenderRow

    LDY #0
    .renderRowLoop
    STY tempIndex
    LDX SpriteRenderList,Y

    ; If row is below new sprite bounds, skip
    ; This is (NewY1 - rowStart - 1) because C clear
    CLC:LDA SpriteNewY1,X:SBC rowStart:BCC renderNextSprite:TAY

    ; If row is above new sprite bounds, skip
    LDA SpriteNewY0,X:SBC rowEnd:BCS renderNextSprite

    ; Y = number of sprite lines from the row top, minus 1; 7 is a full sprite block
    CPY #7:BCC partialBottom

    ; A <= &F8: full sprite block, otherwise partial sprite block
    ; C set, so we add 7 here
    ADC #6:BCS partialTop

    EOR #255
    ADC SpriteAddrLo,X:STA sprite
    LDA SpriteAddrHi,X:STA sprite+1

    LDY SpriteNewX0,X
    LDA rowAddr:ADC Mul8Lo,Y:STA screen
    LDA rowAddr+1:ADC Mul8Hi,Y:BPL P%+4:SBC #HI(ScreenSize)-1:STA screen+1

    LDA SpriteNewX1,X:SEC:SBC SpriteNewX0,X:TAX
;    LDA #1:STA &FE21
    JSR renderSpriteRow
;    LDA #3:STA &FE21

    .renderNextSprite
    LDY tempIndex
    INY
    CPY spriteRenderNum
    BNE renderRowLoop

    .finishedRenderRow
    JMP rowLoop


    .partialBottom
    ; Y = 0..6, number of lines to render minus 1
    ; A = sprite line (after adding 7 and EORing with 255)
    ADC #7:EOR #255
    ADC SpriteAddrLo,X:STA sprite
    LDA SpriteAddrHi,X:STA sprite+1

	LDA spriteMaskedRoutines+1,Y:STA renderSpriteBranchDest+1
	LDA spriteOverwriteRoutines+1,Y:STA renderSpriteBranchDest-1

    LDY SpriteNewX0,X
    LDA rowAddr:ADC Mul8Lo,Y:STA screen
    LDA rowAddr+1:ADC Mul8Hi,Y:BPL partialCommon:SBC #HI(ScreenSize)-1:BCS partialCommon


    .partialTop
    TAY
	LDA spriteMaskedRoutinesByLine+1,Y:STA renderSpriteBranchDest+1
	LDA spriteOverwriteRoutinesByLine+1,Y:STA renderSpriteBranchDest-1

    LDA SpriteAddrLo,X:STA sprite
    LDA SpriteAddrHi,X:STA sprite+1

    TYA

    LDY SpriteNewX0,X
    SEC:ADC rowAddr:ADC Mul8Lo,Y:STA screen
    LDA rowAddr+1:ADC Mul8Hi,Y:BPL P%+4:SBC #HI(ScreenSize)-1
    
    .partialCommon
    STA screen+1

    LDA SpriteNewX1,X:SEC:SBC SpriteNewX0,X:TAX
;    LDA #1:STA &FE21
    JSR renderSpriteRow
;    LDA #3:STA &FE21

	LDA #LO(renderMasked0):STA renderSpriteBranchDest+1
	LDA #renderOverwrite0 - renderSpriteBranchDest:STA renderSpriteBranchDest-1

    JMP renderNextSprite
}
